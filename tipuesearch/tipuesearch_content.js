var tipuesearch = {"pages":[{"title":" heatcompact3d ","text":"heatcompact3d A 3D heat equation solver based on 6th order compact finite\ndifferences schemes. Developer Info Thibault Lestang","tags":"home","loc":"index.html"},{"title":"time_integrator_type – heatcompact3d ","text":"type, public, abstract :: time_integrator_type Contents Variables starttime endtime dt Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure( integrate_proc ), public, deferred :: integrate subroutine integrate_proc(self, afield) Prototype Arguments Type Intent Optional Attributes Name class( time_integrator_type ), intent(in) :: self class( field_type ), intent(inout) :: afield","tags":"","loc":"type/time_integrator_type.html"},{"title":"euler_integrator_type – heatcompact3d ","text":"type, public, extends( time_integrator_type ) :: euler_integrator_type Contents Variables starttime endtime dt alpha Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt real, public :: alpha = 1. Type-Bound Procedures procedure, public :: integrate => integrate_euler public  subroutine integrate_euler (self, afield) Arguments Type Intent Optional Attributes Name class( euler_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield","tags":"","loc":"type/euler_integrator_type.html"},{"title":"AB2_integrator_type – heatcompact3d ","text":"type, public, extends( time_integrator_type ) :: AB2_integrator_type Contents Variables starttime endtime dt Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure, public :: integrate => integrate_AB2 public  subroutine integrate_AB2 (self, afield) Arguments Type Intent Optional Attributes Name class( AB2_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield","tags":"","loc":"type/ab2_integrator_type.html"},{"title":"RK3_integrator_type – heatcompact3d ","text":"type, public, extends( time_integrator_type ) :: RK3_integrator_type Contents Variables starttime endtime dt Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure, public :: integrate => integrate_RK3 public  subroutine integrate_RK3 (self, afield) Arguments Type Intent Optional Attributes Name class( RK3_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield","tags":"","loc":"type/rk3_integrator_type.html"},{"title":"differentiator_type – heatcompact3d ","text":"type, public :: differentiator_type Implements differentiation over a periodic stencil. differentiator_type provides access a a unique type-bound\nprocedure diff Contents Type-Bound Procedures diff Type-Bound Procedures procedure, public :: diff => diff_periodic public pure function diff_periodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nassuming periodic boundaries. For instance, with a four point\nstencil and weights Arguments Type Intent Optional Attributes Name class( differentiator_type ), intent(in) :: self real, intent(in) :: f (:) Function to be derive, evaluated on pencil real, intent(in) :: dx Step size Return Value real, allocatable, (:) Derivative, evaluated on pencil","tags":"","loc":"type/differentiator_type.html"},{"title":"nonperiodic_differentiator_type – heatcompact3d ","text":"type, public, extends( differentiator_type ) :: nonperiodic_differentiator_type Contents Variables east_stencils west_stencils Type-Bound Procedures diff Components Type Visibility Attributes Name Initial type( stencil_type ), public :: east_stencils (2) type( stencil_type ), public :: west_stencils (2) Type-Bound Procedures procedure, public :: diff => diff_nonperiodic public pure function diff_nonperiodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nthen apply boundary conditions on both ends. Boundary\nconditions are applied as arrays of type stencil_type Arguments Type Intent Optional Attributes Name class( nonperiodic_differentiator_type ), intent(in) :: self real, intent(in) :: f (:) real, intent(in) :: dx Return Value real, allocatable, (:)","tags":"","loc":"type/nonperiodic_differentiator_type.html"},{"title":"field_type – heatcompact3d ","text":"type, public, abstract :: field_type Implement a 3D scalar field, for instance a temperature field. type ( field_type ) = afield real :: u0 ( nx , ny , nz ), dx afield = field_type ( u0 , dx ) Contents Variables data dx Type-Bound Procedures nz ny nx dump is_equal rhs operator(+) operator(-) operator(*) Components Type Visibility Attributes Name Initial real, public, allocatable :: data (:,:,:) real, public :: dx Discrete mesh spacing Type-Bound Procedures procedure, public :: nz public pure function nz (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: ny public pure function ny (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: nx public pure function nx (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: dump public  subroutine dump (self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string procedure, public :: is_equal public pure function is_equal (self, lhs, tol) Compare two field_type instance based on their data value f1 = field_type ( u0 , dx ) f2 = field_type ( u0 , dx2 ) f1 % is_equal ( f2 ) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical procedure( rhs_field ), public, deferred :: rhs pure function rhs_field(self) Prototype Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value real, allocatable, (:,:,:) generic, public :: operator(+) => field_add_field, field_add_real public pure function field_add_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable public pure function field_add_real (self, a) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self real, intent(in) :: a (:,:,:) Return Value class( field_type ), allocatable generic, public :: operator(-) => field_sub_field public pure function field_sub_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable generic, public :: operator(*) => field_mul_real public pure function field_mul_real (self, a) Multiply a field_cpu_type instance by a real number. f1 = field_cpu_type(u0, dx)\nf2 = f1 * 1.3\nf2%is_equal(field_cpu_type(u0 * 1.3, dx)) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value class( field_type ), allocatable","tags":"","loc":"type/field_type.html"},{"title":"boundary_type – heatcompact3d ","text":"type, public :: boundary_type Contents Variables first_order_east second_order_east first_order_west second_order_west Components Type Visibility Attributes Name Initial type( stencil_type ), public :: first_order_east (2) type( stencil_type ), public :: second_order_east (2) type( stencil_type ), public :: first_order_west (2) type( stencil_type ), public :: second_order_west (2)","tags":"","loc":"type/boundary_type.html"},{"title":"field_cpu_type – heatcompact3d ","text":"type, public, extends( field_type ) :: field_cpu_type Contents Variables data dx Constructor field_cpu_type Type-Bound Procedures nz ny nx dump is_equal operator(+) operator(-) operator(*) rhs Components Type Visibility Attributes Name Initial real, public, allocatable :: data (:,:,:) real, public :: dx Discrete mesh spacing Constructor public        interface field_cpu_type public  function field_cpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_cpu_type ) Type-Bound Procedures procedure, public :: nz public pure function nz (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: ny public pure function ny (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: nx public pure function nx (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: dump public  subroutine dump (self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string procedure, public :: is_equal public pure function is_equal (self, lhs, tol) Compare two field_type instance based on their data value f1 = field_type ( u0 , dx ) f2 = field_type ( u0 , dx2 ) f1 % is_equal ( f2 ) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical generic, public :: operator(+) => field_add_field, field_add_real public pure function field_add_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable public pure function field_add_real (self, a) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self real, intent(in) :: a (:,:,:) Return Value class( field_type ), allocatable generic, public :: operator(-) => field_sub_field public pure function field_sub_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable generic, public :: operator(*) => field_mul_real public pure function field_mul_real (self, a) Multiply a field_cpu_type instance by a real number. f1 = field_cpu_type(u0, dx)\nf2 = f1 * 1.3\nf2%is_equal(field_cpu_type(u0 * 1.3, dx)) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value class( field_type ), allocatable procedure, public :: rhs public pure function rhs (self) Evaluates right hand side of heat equation on a field instance. Arguments Type Intent Optional Attributes Name class( field_cpu_type ), intent(in) :: self Return Value real, allocatable, (:,:,:)","tags":"","loc":"type/field_cpu_type.html"},{"title":"stencil_type – heatcompact3d ","text":"type, public :: stencil_type Contents Variables nodes coeffs lower upper Type-Bound Procedures apply apply_along get_lower get_upper is_equal flip operator(*) Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodes (:) real, public, allocatable :: coeffs (:) real, public :: lower real, public :: upper Type-Bound Procedures procedure, public :: apply => apply_stencil public pure function apply_stencil (self, f, ref) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) integer, intent(in) :: ref Return Value real procedure, public :: apply_along => apply_stencil_along public pure function apply_stencil_along (self, f) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) Return Value real, allocatable, (:) procedure, public :: get_lower public pure elemental function get_lower (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real procedure, public :: get_upper public pure elemental function get_upper (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real procedure, public :: is_equal public pure function is_equal (self, st, tol) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self type( stencil_type ), intent(in) :: st real, intent(in) :: tol Return Value logical procedure, public :: flip public pure elemental function flip (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value type( stencil_type ) generic, public :: operator(*) => stencil_mul_real public pure elemental function stencil_mul_real (self, a) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: a Return Value type( stencil_type )","tags":"","loc":"type/stencil_type.html"},{"title":"field_gpu_type – heatcompact3d ","text":"type, public, extends( field_type ) :: field_gpu_type Contents Variables data dx Constructor field_gpu_type Type-Bound Procedures nz ny nx dump is_equal operator(+) operator(-) operator(*) rhs Components Type Visibility Attributes Name Initial real, public, allocatable :: data (:,:,:) real, public :: dx Discrete mesh spacing Constructor public        interface field_gpu_type public  function field_gpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_gpu_type ) Type-Bound Procedures procedure, public :: nz public pure function nz (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: ny public pure function ny (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: nx public pure function nx (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: dump public  subroutine dump (self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string procedure, public :: is_equal public pure function is_equal (self, lhs, tol) Compare two field_type instance based on their data value f1 = field_type ( u0 , dx ) f2 = field_type ( u0 , dx2 ) f1 % is_equal ( f2 ) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical generic, public :: operator(+) => field_add_field, field_add_real public pure function field_add_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable public pure function field_add_real (self, a) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self real, intent(in) :: a (:,:,:) Return Value class( field_type ), allocatable generic, public :: operator(-) => field_sub_field public pure function field_sub_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable generic, public :: operator(*) => field_mul_real public pure function field_mul_real (self, a) Multiply a field_cpu_type instance by a real number. f1 = field_cpu_type(u0, dx)\nf2 = f1 * 1.3\nf2%is_equal(field_cpu_type(u0 * 1.3, dx)) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value class( field_type ), allocatable procedure, public :: rhs public pure function rhs (self) Arguments Type Intent Optional Attributes Name class( field_gpu_type ), intent(in) :: self Return Value real, allocatable, (:,:,:)","tags":"","loc":"type/field_gpu_type.html"},{"title":"integrate_proc – heatcompact3d","text":"abstract interface public  subroutine integrate_proc(self, afield) Arguments Type Intent Optional Attributes Name class( time_integrator_type ), intent(in) :: self class( field_type ), intent(inout) :: afield","tags":"","loc":"interface/integrate_proc.html"},{"title":"thomas – heatcompact3d","text":"public pure function thomas(as, bs, cs, ds) result(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: as (:) real, intent(in) :: bs (:) real, intent(in) :: cs (:) real, intent(in) :: ds (:) Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/thomas.html"},{"title":"euler_timestep – heatcompact3d","text":"public pure function euler_timestep(afield, dt) result(res) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: afield real, intent(in) :: dt Return Value class( field_type ), allocatable Contents","tags":"","loc":"proc/euler_timestep.html"},{"title":"integrate_euler – heatcompact3d","text":"public  subroutine integrate_euler(self, afield) Arguments Type Intent Optional Attributes Name class( euler_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield Contents","tags":"","loc":"proc/integrate_euler.html"},{"title":"integrate_AB2 – heatcompact3d","text":"public  subroutine integrate_AB2(self, afield) Arguments Type Intent Optional Attributes Name class( AB2_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield Contents","tags":"","loc":"proc/integrate_ab2.html"},{"title":"integrate_RK3 – heatcompact3d","text":"public  subroutine integrate_RK3(self, afield) Arguments Type Intent Optional Attributes Name class( RK3_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield Contents","tags":"","loc":"proc/integrate_rk3.html"},{"title":"AB2_timestep – heatcompact3d","text":"public  subroutine AB2_timestep(f1, f2, dt) Arguments Type Intent Optional Attributes Name class( field_type ), intent(inout), allocatable :: f1 class( field_type ), intent(inout), allocatable :: f2 real, intent(in) :: dt Contents","tags":"","loc":"proc/ab2_timestep.html"},{"title":"sixth_order_compact_1_nonperiodic – heatcompact3d","text":"public pure function sixth_order_compact_1_nonperiodic(east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) Contents","tags":"","loc":"proc/sixth_order_compact_1_nonperiodic.html"},{"title":"sixth_order_compact_1_periodic – heatcompact3d","text":"public pure function sixth_order_compact_1_periodic() Arguments None Return Value type( differentiator_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_1_periodic.html"},{"title":"sixth_order_compact_2_nonperiodic – heatcompact3d","text":"public pure function sixth_order_compact_2_nonperiodic(east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) Contents","tags":"","loc":"proc/sixth_order_compact_2_nonperiodic.html"},{"title":"sixth_order_compact_2_periodic – heatcompact3d","text":"public pure function sixth_order_compact_2_periodic() Arguments None Return Value type( differentiator_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_2_periodic.html"},{"title":"diff_nonperiodic – heatcompact3d","text":"public pure function diff_nonperiodic(self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nthen apply boundary conditions on both ends. Boundary\nconditions are applied as arrays of type stencil_type Arguments Type Intent Optional Attributes Name class( nonperiodic_differentiator_type ), intent(in) :: self real, intent(in) :: f (:) real, intent(in) :: dx Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/diff_nonperiodic.html"},{"title":"diff_periodic – heatcompact3d","text":"public pure function diff_periodic(self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nassuming periodic boundaries. For instance, with a four point\nstencil and weights Arguments Type Intent Optional Attributes Name class( differentiator_type ), intent(in) :: self real, intent(in) :: f (:) Function to be derive, evaluated on pencil real, intent(in) :: dx Step size Return Value real, allocatable, (:) Derivative, evaluated on pencil Contents","tags":"","loc":"proc/diff_periodic.html"},{"title":"reverse – heatcompact3d","text":"public pure function reverse(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/reverse.html"},{"title":"sixth_order_compact_1 – heatcompact3d","text":"public interface sixth_order_compact_1 Contents Module Procedures sixth_order_compact_1_periodic sixth_order_compact_1_nonperiodic Module Procedures public pure function sixth_order_compact_1_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_1_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type )","tags":"","loc":"interface/sixth_order_compact_1.html"},{"title":"sixth_order_compact_2 – heatcompact3d","text":"public interface sixth_order_compact_2 Contents Module Procedures sixth_order_compact_2_periodic sixth_order_compact_2_nonperiodic Module Procedures public pure function sixth_order_compact_2_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_2_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type )","tags":"","loc":"interface/sixth_order_compact_2.html"},{"title":"nx – heatcompact3d","text":"public pure function nx(self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer Contents","tags":"","loc":"proc/nx.html"},{"title":"ny – heatcompact3d","text":"public pure function ny(self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer Contents","tags":"","loc":"proc/ny.html"},{"title":"nz – heatcompact3d","text":"public pure function nz(self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer Contents","tags":"","loc":"proc/nz.html"},{"title":"is_equal – heatcompact3d","text":"public pure function is_equal(self, lhs, tol) Compare two field_type instance based on their data value f1 = field_type ( u0 , dx ) f2 = field_type ( u0 , dx2 ) f1 % is_equal ( f2 ) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical Contents","tags":"","loc":"proc/is_equal.html"},{"title":"field_add_field – heatcompact3d","text":"public pure function field_add_field(self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable Contents","tags":"","loc":"proc/field_add_field.html"},{"title":"field_add_real – heatcompact3d","text":"public pure function field_add_real(self, a) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self real, intent(in) :: a (:,:,:) Return Value class( field_type ), allocatable Contents","tags":"","loc":"proc/field_add_real.html"},{"title":"field_sub_field – heatcompact3d","text":"public pure function field_sub_field(self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable Contents","tags":"","loc":"proc/field_sub_field.html"},{"title":"field_mul_real – heatcompact3d","text":"public pure function field_mul_real(self, a) Multiply a field_cpu_type instance by a real number. f1 = field_cpu_type(u0, dx)\nf2 = f1 * 1.3\nf2%is_equal(field_cpu_type(u0 * 1.3, dx)) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value class( field_type ), allocatable Contents","tags":"","loc":"proc/field_mul_real.html"},{"title":"dump – heatcompact3d","text":"public  subroutine dump(self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string Contents","tags":"","loc":"proc/dump.html"},{"title":"rhs_field – heatcompact3d","text":"interface public pure function rhs_field(self) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value real,allocatable,(:,:,:)","tags":"","loc":"interface/rhs_field.html"},{"title":"sixth_order_compact_stencil – heatcompact3d","text":"public pure function sixth_order_compact_stencil() Arguments None Return Value type( stencil_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_stencil.html"},{"title":"sixth_order_compact_second_stencil – heatcompact3d","text":"public pure function sixth_order_compact_second_stencil() Arguments None Return Value type( stencil_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_second_stencil.html"},{"title":"get_dirichlet_boundary – heatcompact3d","text":"public  function get_dirichlet_boundary() Arguments None Return Value type( boundary_type ) Contents None","tags":"","loc":"proc/get_dirichlet_boundary.html"},{"title":"field_cpu_constructor – heatcompact3d","text":"public  function field_cpu_constructor(initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_cpu_type ) Contents","tags":"","loc":"proc/field_cpu_constructor.html"},{"title":"rhs – heatcompact3d","text":"public pure function rhs(self) Uses differentiate Evaluates right hand side of heat equation on a field instance. Arguments Type Intent Optional Attributes Name class( field_cpu_type ), intent(in) :: self Return Value real, allocatable, (:,:,:) Contents","tags":"","loc":"proc/rhs.html"},{"title":"field_cpu_type – heatcompact3d","text":"public interface field_cpu_type Contents Module Procedures field_cpu_constructor Module Procedures public  function field_cpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_cpu_type )","tags":"","loc":"interface/field_cpu_type.html"},{"title":"is_equal – heatcompact3d","text":"public pure function is_equal(self, st, tol) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self type( stencil_type ), intent(in) :: st real, intent(in) :: tol Return Value logical Contents","tags":"","loc":"proc/is_equal~2.html"},{"title":"stencil_mul_real – heatcompact3d","text":"public pure elemental function stencil_mul_real(self, a) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: a Return Value type( stencil_type ) Contents","tags":"","loc":"proc/stencil_mul_real.html"},{"title":"flip – heatcompact3d","text":"public pure elemental function flip(self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value type( stencil_type ) Contents","tags":"","loc":"proc/flip.html"},{"title":"get_upper – heatcompact3d","text":"public pure elemental function get_upper(self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real Contents","tags":"","loc":"proc/get_upper.html"},{"title":"get_lower – heatcompact3d","text":"public pure elemental function get_lower(self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real Contents","tags":"","loc":"proc/get_lower.html"},{"title":"apply_stencil – heatcompact3d","text":"public pure function apply_stencil(self, f, ref) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) integer, intent(in) :: ref Return Value real Contents","tags":"","loc":"proc/apply_stencil.html"},{"title":"apply_stencil_along – heatcompact3d","text":"public pure function apply_stencil_along(self, f) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/apply_stencil_along.html"},{"title":"field_gpu_constructor – heatcompact3d","text":"public  function field_gpu_constructor(initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_gpu_type ) Contents","tags":"","loc":"proc/field_gpu_constructor.html"},{"title":"rhs – heatcompact3d","text":"public pure function rhs(self) Arguments Type Intent Optional Attributes Name class( field_gpu_type ), intent(in) :: self Return Value real, allocatable, (:,:,:) Contents","tags":"","loc":"proc/rhs~2.html"},{"title":"rhs_x – heatcompact3d","text":"public pure subroutine rhs_x(data, rhs, temp) Arguments Type Intent Optional Attributes Name real, intent(in) :: data (:,:,:) real, intent(out) :: rhs (:,:,:) real, intent(inout) :: temp (:,:,:) Contents","tags":"","loc":"proc/rhs_x.html"},{"title":"rhs_y – heatcompact3d","text":"public pure subroutine rhs_y(data, rhs, temp) Arguments Type Intent Optional Attributes Name real, intent(in) :: data (:,:,:) real, intent(inout) :: rhs (:,:,:) real, intent(inout) :: temp (:,:,:) Contents","tags":"","loc":"proc/rhs_y.html"},{"title":"rhs_z – heatcompact3d","text":"public pure subroutine rhs_z(data, rhs, temp) Arguments Type Intent Optional Attributes Name real, intent(in) :: data (:,:,:) real, intent(inout) :: rhs (:,:,:) real, intent(inout) :: temp (:,:,:) Contents","tags":"","loc":"proc/rhs_z.html"},{"title":"field_gpu_type – heatcompact3d","text":"public interface field_gpu_type Contents Module Procedures field_gpu_constructor Module Procedures public  function field_gpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_gpu_type )","tags":"","loc":"interface/field_gpu_type.html"},{"title":"thomas_module – heatcompact3d","text":"Contents Functions thomas Functions public pure function thomas (as, bs, cs, ds) result(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: as (:) real, intent(in) :: bs (:) real, intent(in) :: cs (:) real, intent(in) :: ds (:) Return Value real, allocatable, (:)","tags":"","loc":"module/thomas_module.html"},{"title":"time_integrator – heatcompact3d","text":"Uses field Contents Abstract Interfaces integrate_proc Derived Types time_integrator_type euler_integrator_type AB2_integrator_type RK3_integrator_type Functions euler_timestep Subroutines integrate_euler integrate_AB2 integrate_RK3 AB2_timestep Abstract Interfaces abstract interface public  subroutine integrate_proc(self, afield) Arguments Type Intent Optional Attributes Name class( time_integrator_type ), intent(in) :: self class( field_type ), intent(inout) :: afield Derived Types type, public :: time_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure\n(integrate_proc)                    ,                  public\n                  :: integrate type, public, extends( time_integrator_type ) :: euler_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt real, public :: alpha = 1. Type-Bound Procedures procedure\n                    ,                  public\n                  :: integrate => integrate_euler Subroutine type, public, extends( time_integrator_type ) :: AB2_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure\n                    ,                  public\n                  :: integrate => integrate_AB2 Subroutine type, public, extends( time_integrator_type ) :: RK3_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure\n                    ,                  public\n                  :: integrate => integrate_RK3 Subroutine Functions public pure function euler_timestep (afield, dt) result(res) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: afield real, intent(in) :: dt Return Value class( field_type ), allocatable Subroutines public  subroutine integrate_euler (self, afield) Arguments Type Intent Optional Attributes Name class( euler_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield public  subroutine integrate_AB2 (self, afield) Arguments Type Intent Optional Attributes Name class( AB2_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield public  subroutine integrate_RK3 (self, afield) Arguments Type Intent Optional Attributes Name class( RK3_integrator_type ), intent(in) :: self class( field_type ), intent(inout), allocatable :: afield public  subroutine AB2_timestep (f1, f2, dt) Arguments Type Intent Optional Attributes Name class( field_type ), intent(inout), allocatable :: f1 class( field_type ), intent(inout), allocatable :: f2 real, intent(in) :: dt","tags":"","loc":"module/time_integrator.html"},{"title":"differentiate – heatcompact3d","text":"This module implements differentiation over a one dimensional\npencil.  It exports concrete derived types differentiator_type :: periodic differentiation nonperiodic_differentiator_type :: non periodic differentiation Both types provide access to a single type-procedure diff that\nperforms the differentiation and return the derivative evaluated\nover the input pencil. Instances of differentiator derived types are created on the\nclient side via constructor procedures <method>_<order> (e.g. sixth_order_compact_1 ). These constructor procedures are\nimplemented as a generic interface to concrete constructors for\nthe periodic case (no boundary conditions are specified) or the\nnoneriodic case (boundary conditions are specified). See module boundary_schemes . use boundary_schemes, only:: get_dirichlet_4th\nreal :: f(:), df(:), dx\n! ...\n! ...\ndifferentiatior = sixth_order_compact_1( &\n     & east = get_dirichlet_4th(), &\n     & west = get_dirichlet_4th(), &\n     & )\ndf = differentiatior%diff(f, dx) Uses thomas_module boundary_schemes stencil Contents Interfaces sixth_order_compact_1 sixth_order_compact_2 Derived Types differentiator_type nonperiodic_differentiator_type Functions sixth_order_compact_1_nonperiodic sixth_order_compact_1_periodic sixth_order_compact_2_nonperiodic sixth_order_compact_2_periodic diff_nonperiodic diff_periodic reverse Interfaces public        interface sixth_order_compact_1 public pure function sixth_order_compact_1_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_1_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) public        interface sixth_order_compact_2 public pure function sixth_order_compact_2_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_2_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) Derived Types type, public :: differentiator_type Implements differentiation over a periodic stencil. differentiator_type provides access a a unique type-bound\nprocedure diff Type-Bound Procedures procedure\n                    ,                  public\n                  :: diff => diff_periodic Function type, public, extends( differentiator_type ) :: nonperiodic_differentiator_type Components Type Visibility Attributes Name Initial type( stencil_type ), public :: east_stencils (2) type( stencil_type ), public :: west_stencils (2) Type-Bound Procedures procedure\n                    ,                  public\n                  :: diff => diff_nonperiodic Function Functions public pure function sixth_order_compact_1_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) public pure function sixth_order_compact_1_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_2_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) public pure function sixth_order_compact_2_periodic () Arguments None Return Value type( differentiator_type ) public pure function diff_nonperiodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nthen apply boundary conditions on both ends. Boundary\nconditions are applied as arrays of type stencil_type Arguments Type Intent Optional Attributes Name class( nonperiodic_differentiator_type ), intent(in) :: self real, intent(in) :: f (:) real, intent(in) :: dx Return Value real, allocatable, (:) public pure function diff_periodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nassuming periodic boundaries. For instance, with a four point\nstencil and weights Read more… Arguments Type Intent Optional Attributes Name class( differentiator_type ), intent(in) :: self real, intent(in) :: f (:) Function to be derive, evaluated on pencil real, intent(in) :: dx Step size Return Value real, allocatable, (:) Derivative, evaluated on pencil public pure function reverse (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real, allocatable, (:)","tags":"","loc":"module/differentiate.html"},{"title":"field – heatcompact3d","text":"Contents Interfaces rhs_field Derived Types field_type Functions nx ny nz is_equal field_add_field field_add_real field_sub_field field_mul_real Subroutines dump Interfaces interface public pure function rhs_field(self) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value real, allocatable, (:,:,:) Derived Types type, public :: field_type Implement a 3D scalar field, for instance a temperature field. Read more… Components Type Visibility Attributes Name Initial real, public, allocatable :: data (:,:,:) real, public :: dx Discrete mesh spacing Type-Bound Procedures procedure\n                    ,                  public\n                  :: nz Function procedure\n                    ,                  public\n                  :: ny Function procedure\n                    ,                  public\n                  :: nx Function procedure\n                    ,                  public\n                  :: dump Subroutine procedure\n                    ,                  public\n                  :: is_equal Function procedure\n(rhs_field)                    ,                  public\n                  :: rhs generic,\n                  public\n                  :: operator(+) =>\n                    field_add_field, field_add_real generic,\n                  public\n                  :: operator(-) =>\n                    field_sub_field generic,\n                  public\n                  :: operator(*) =>\n                    field_mul_real Functions public pure function nx (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer public pure function ny (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer public pure function nz (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer public pure function is_equal (self, lhs, tol) Compare two field_type instance based on their data value Read more… Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical public pure function field_add_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable public pure function field_add_real (self, a) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self real, intent(in) :: a (:,:,:) Return Value class( field_type ), allocatable public pure function field_sub_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value class( field_type ), allocatable public pure function field_mul_real (self, a) Multiply a field_cpu_type instance by a real number. Read more… Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value class( field_type ), allocatable Subroutines public  subroutine dump (self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string","tags":"","loc":"module/field.html"},{"title":"boundary_schemes – heatcompact3d","text":"Uses stencil Contents Variables sixth_order_compact_coeffs sixth_order_compact_coeffs_2 Derived Types boundary_type Functions sixth_order_compact_stencil sixth_order_compact_second_stencil get_dirichlet_boundary Variables Type Visibility Attributes Name Initial real, public, parameter :: sixth_order_compact_coeffs (4) = [-1./36., -7./9., +7./9., +1./36.] real, public, parameter :: sixth_order_compact_coeffs_2 (5) = [3./44., 12./11., -2.*(12./11.+3./44.), 12./11., 3./44.] Derived Types type, public :: boundary_type Components Type Visibility Attributes Name Initial type( stencil_type ), public :: first_order_east (2) type( stencil_type ), public :: second_order_east (2) type( stencil_type ), public :: first_order_west (2) type( stencil_type ), public :: second_order_west (2) Functions public pure function sixth_order_compact_stencil () Arguments None Return Value type( stencil_type ) public pure function sixth_order_compact_second_stencil () Arguments None Return Value type( stencil_type ) public  function get_dirichlet_boundary () Arguments None Return Value type( boundary_type )","tags":"","loc":"module/boundary_schemes.html"},{"title":"field_cpu – heatcompact3d","text":"Uses field Contents Interfaces field_cpu_type Derived Types field_cpu_type Functions field_cpu_constructor rhs Interfaces public        interface field_cpu_type public  function field_cpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_cpu_type ) Derived Types type, public, extends( field_type ) :: field_cpu_type Components Type Visibility Attributes Name Initial real, public, allocatable :: data (:,:,:) real, public :: dx Discrete mesh spacing Constructor public\n\n                    \n                    function field_cpu_constructor (initial, dx) Type-Bound Procedures procedure\n                    ,                  public\n                  :: nz Function procedure\n                    ,                  public\n                  :: ny Function procedure\n                    ,                  public\n                  :: nx Function procedure\n                    ,                  public\n                  :: dump Subroutine procedure\n                    ,                  public\n                  :: is_equal Function generic,\n                  public\n                  :: operator(+) =>\n                    field_add_field, field_add_real generic,\n                  public\n                  :: operator(-) =>\n                    field_sub_field generic,\n                  public\n                  :: operator(*) =>\n                    field_mul_real procedure\n                    ,                  public\n                  :: rhs Function Functions public  function field_cpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_cpu_type ) public pure function rhs (self) Evaluates right hand side of heat equation on a field instance. Arguments Type Intent Optional Attributes Name class( field_cpu_type ), intent(in) :: self Return Value real, allocatable, (:,:,:)","tags":"","loc":"module/field_cpu.html"},{"title":"stencil – heatcompact3d","text":"Contents Derived Types stencil_type Functions is_equal stencil_mul_real flip get_upper get_lower apply_stencil apply_stencil_along Derived Types type, public :: stencil_type Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodes (:) real, public, allocatable :: coeffs (:) real, public :: lower real, public :: upper Type-Bound Procedures procedure\n                    ,                  public\n                  :: apply => apply_stencil Function procedure\n                    ,                  public\n                  :: apply_along => apply_stencil_along Function procedure\n                    ,                  public\n                  :: get_lower Function procedure\n                    ,                  public\n                  :: get_upper Function procedure\n                    ,                  public\n                  :: is_equal Function procedure\n                    ,                  public\n                  :: flip Function generic,\n                  public\n                  :: operator(*) =>\n                    stencil_mul_real Functions public pure function is_equal (self, st, tol) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self type( stencil_type ), intent(in) :: st real, intent(in) :: tol Return Value logical public pure elemental function stencil_mul_real (self, a) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: a Return Value type( stencil_type ) public pure elemental function flip (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value type( stencil_type ) public pure elemental function get_upper (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real public pure elemental function get_lower (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real public pure function apply_stencil (self, f, ref) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) integer, intent(in) :: ref Return Value real public pure function apply_stencil_along (self, f) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) Return Value real, allocatable, (:)","tags":"","loc":"module/stencil.html"},{"title":"field_gpu – heatcompact3d","text":"Uses cudafor field Contents Interfaces field_gpu_type Derived Types field_gpu_type Functions field_gpu_constructor rhs Subroutines rhs_x rhs_y rhs_z Interfaces public        interface field_gpu_type public  function field_gpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_gpu_type ) Derived Types type, public, extends( field_type ) :: field_gpu_type Components Type Visibility Attributes Name Initial real, public, allocatable :: data (:,:,:) real, public :: dx Discrete mesh spacing Constructor public\n\n                    \n                    function field_gpu_constructor (initial, dx) Type-Bound Procedures procedure\n                    ,                  public\n                  :: nz Function procedure\n                    ,                  public\n                  :: ny Function procedure\n                    ,                  public\n                  :: nx Function procedure\n                    ,                  public\n                  :: dump Subroutine procedure\n                    ,                  public\n                  :: is_equal Function generic,\n                  public\n                  :: operator(+) =>\n                    field_add_field, field_add_real generic,\n                  public\n                  :: operator(-) =>\n                    field_sub_field generic,\n                  public\n                  :: operator(*) =>\n                    field_mul_real procedure\n                    ,                  public\n                  :: rhs Function Functions public  function field_gpu_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_gpu_type ) public pure function rhs (self) Arguments Type Intent Optional Attributes Name class( field_gpu_type ), intent(in) :: self Return Value real, allocatable, (:,:,:) Subroutines public pure subroutine rhs_x (data, rhs, temp) Arguments Type Intent Optional Attributes Name real, intent(in) :: data (:,:,:) real, intent(out) :: rhs (:,:,:) real, intent(inout) :: temp (:,:,:) public pure subroutine rhs_y (data, rhs, temp) Arguments Type Intent Optional Attributes Name real, intent(in) :: data (:,:,:) real, intent(inout) :: rhs (:,:,:) real, intent(inout) :: temp (:,:,:) public pure subroutine rhs_z (data, rhs, temp) Arguments Type Intent Optional Attributes Name real, intent(in) :: data (:,:,:) real, intent(inout) :: rhs (:,:,:) real, intent(inout) :: temp (:,:,:)","tags":"","loc":"module/field_gpu.html"},{"title":"module_thomas.f90 – heatcompact3d","text":"Contents Modules thomas_module Source Code module_thomas.f90 Source Code module thomas_module implicit none contains pure function thomas ( as , bs , cs , ds ) result ( x ) real , intent ( in ) :: as (:), bs (:), cs (:), ds (:) real , allocatable :: x (:), b (:), d (:) integer :: i , n real :: w allocate ( d , source = ds ) allocate ( b , source = bs ) allocate ( x , source = ds ) n = size ( ds ) do i = 2 , n w = as ( i ) / b ( i - 1 ) b ( i ) = b ( i ) - w * cs ( i - 1 ) d ( i ) = d ( i ) - w * d ( i - 1 ) end do x ( n ) = d ( n ) / b ( n ) do i = n - 1 , 1 , - 1 x ( i ) = ( d ( i ) - cs ( i ) * x ( i + 1 )) / b ( i ) end do end function thomas end module thomas_module","tags":"","loc":"sourcefile/module_thomas.f90.html"},{"title":"module_time_integration.f90 – heatcompact3d","text":"Contents Modules time_integrator Source Code module_time_integration.f90 Source Code module time_integrator use field , only : field_type implicit none type , abstract :: time_integrator_type real :: starttime , endtime , dt contains procedure ( integrate_proc ), public , & & deferred :: integrate end type time_integrator_type type , extends ( time_integrator_type ) :: euler_integrator_type real :: alpha = 1. contains procedure :: integrate => integrate_euler end type euler_integrator_type type , extends ( time_integrator_type ) :: AB2_integrator_type contains procedure :: integrate => integrate_AB2 end type AB2_integrator_type type , extends ( time_integrator_type ) :: RK3_integrator_type contains procedure :: integrate => integrate_RK3 end type RK3_integrator_type abstract interface subroutine integrate_proc ( self , afield ) import time_integrator_type , field_type class ( time_integrator_type ), intent ( in ) :: self class ( field_type ), intent ( inout ) :: afield end subroutine integrate_proc end interface contains subroutine integrate_euler ( self , afield ) class ( euler_integrator_type ), intent ( in ) :: self class ( field_type ), allocatable , intent ( inout ) :: afield integer :: nt integer :: i nt = floor (( self % endtime - self % starttime ) / self % dt ) do i = 1 , nt afield = euler_timestep ( afield , self % dt ) end do end subroutine integrate_euler subroutine integrate_AB2 ( self , afield ) class ( AB2_integrator_type ), intent ( in ) :: self class ( field_type ), allocatable , intent ( inout ) :: afield class ( field_type ), allocatable :: f1 , f2 integer :: nt integer :: i nt = floor (( self % endtime - self % starttime ) / self % dt ) f1 = afield f2 = euler_timestep ( afield , self % dt ) do i = 2 , nt call AB2_timestep ( f1 , f2 , self % dt ) end do afield = f2 end subroutine integrate_AB2 subroutine integrate_RK3 ( self , afield ) class ( RK3_integrator_type ), intent ( in ) :: self class ( field_type ), allocatable , intent ( inout ) :: afield class ( field_type ), allocatable :: afield2 integer :: nt , i nt = floor (( self % endtime - self % starttime ) / self % dt ) do i = 1 , nt ! First fractional step is Euler like afield2 = afield + afield % rhs () * ( 8. / 1 5. ) * self % dt ! Second and third steps are AB2 like afield = afield2 + afield2 % rhs () * ( 5. / 1 2. ) * self % dt & & + afield % rhs () * ( - 1 7. / 6 0. ) * self % dt afield = afield + afield % rhs () * ( 3. / 4. ) * self % dt & & + afield2 % rhs () * ( - 5. / 1 2. ) * self % dt end do end subroutine integrate_RK3 pure function euler_timestep ( afield , dt ) result ( res ) class ( field_type ), intent ( in ) :: afield real , intent ( in ) :: dt class ( field_type ), allocatable :: res res = afield + afield % rhs () * dt end function euler_timestep subroutine AB2_timestep ( f1 , f2 , dt ) class ( field_type ), allocatable , intent ( inout ) :: f1 , f2 real , intent ( in ) :: dt f2 = f2 + f2 % rhs () * 1.5 * dt + ( - 1. * f1 % rhs () * 0.5 * dt ) f1 = f2 end subroutine AB2_timestep end module time_integrator","tags":"","loc":"sourcefile/module_time_integration.f90.html"},{"title":"module_differentiate.f90 – heatcompact3d","text":"Contents Modules differentiate Source Code module_differentiate.f90 Source Code module differentiate !! This module implements differentiation over a one dimensional !! pencil.  It exports concrete derived types !! !! - `differentiator_type` :: periodic differentiation !! - `nonperiodic_differentiator_type` :: non periodic differentiation !! !! Both types provide access to a single type-procedure `diff` that !! performs the differentiation and return the derivative evaluated !! over the input pencil. !! !! Instances of differentiator derived types are created on the !! client side via constructor procedures `<method>_<order>` !! (e.g. `sixth_order_compact_1`). These constructor procedures are !! implemented as a generic interface to concrete constructors for !! the periodic case (no boundary conditions are specified) or the !! noneriodic case (boundary conditions are specified). See module !! `boundary_schemes`. !! !! ``` !! use boundary_schemes, only:: get_dirichlet_4th !! real :: f(:), df(:), dx !! ! ... !! ! ... !! differentiatior = sixth_order_compact_1( & !!      & east = get_dirichlet_4th(), & !!      & west = get_dirichlet_4th(), & !!      & ) !! df = differentiatior%diff(f, dx) !! ``` use stencil , only : stencil_type use boundary_schemes , only : boundary_type , sixth_order_compact_stencil , & & sixth_order_compact_second_stencil use thomas_module , only : thomas implicit none type :: differentiator_type !! Implements differentiation over a periodic stencil. !! `differentiator_type` provides access a a unique type-bound !! procedure `diff` private type ( stencil_type ) :: bulk_stencil !! Differentiation stencil contains procedure , public :: diff => diff_periodic end type differentiator_type type , extends ( differentiator_type ) :: nonperiodic_differentiator_type type ( stencil_type ) :: east_stencils ( 2 ) type ( stencil_type ) :: west_stencils ( 2 ) contains procedure , public :: diff => diff_nonperiodic end type nonperiodic_differentiator_type interface sixth_order_compact_1 module procedure :: sixth_order_compact_1_periodic module procedure :: sixth_order_compact_1_nonperiodic end interface sixth_order_compact_1 interface sixth_order_compact_2 module procedure :: sixth_order_compact_2_periodic module procedure :: sixth_order_compact_2_nonperiodic end interface sixth_order_compact_2 contains pure function sixth_order_compact_1_nonperiodic ( east , west ) type ( boundary_type ), intent ( in ) :: east , west type ( nonperiodic_differentiator_type ) :: sixth_order_compact_1_nonperiodic sixth_order_compact_1_nonperiodic = nonperiodic_differentiator_type ( & & east_stencils = east % first_order_east , & & west_stencils = west % first_order_west , & & bulk_stencil = sixth_order_compact_stencil () & & ) end function sixth_order_compact_1_nonperiodic pure function sixth_order_compact_1_periodic () type ( differentiator_type ) :: sixth_order_compact_1_periodic sixth_order_compact_1_periodic = differentiator_type ( & & bulk_stencil = sixth_order_compact_stencil () & & ) end function sixth_order_compact_1_periodic pure function sixth_order_compact_2_nonperiodic ( east , west ) type ( boundary_type ), intent ( in ) :: east , west type ( nonperiodic_differentiator_type ) :: sixth_order_compact_2_nonperiodic sixth_order_compact_2_nonperiodic = nonperiodic_differentiator_type ( & & east_stencils = east % second_order_east , & & west_stencils = west % second_order_west , & & bulk_stencil = sixth_order_compact_second_stencil () & & ) end function sixth_order_compact_2_nonperiodic pure function sixth_order_compact_2_periodic () type ( differentiator_type ) :: sixth_order_compact_2_periodic sixth_order_compact_2_periodic = differentiator_type ( & & bulk_stencil = sixth_order_compact_second_stencil () & & ) end function sixth_order_compact_2_periodic pure function diff_nonperiodic ( self , f , dx ) result ( df ) !! Apply a differentiation stencil along a one dimensional pencil, !! then apply boundary conditions on both ends. Boundary !! conditions are applied as arrays of type `stencil_type` class ( nonperiodic_differentiator_type ), intent ( in ) :: self real , intent ( in ) :: f (:) real , intent ( in ) :: dx real , allocatable :: df (:), rhs (:), diag (:), lower_diag (:), upper_diag (:) integer :: neast , nwest integer :: ref , i ! do loop counters type ( stencil_type ) :: sten real :: alpha_coeffs neast = size ( self % east_stencils ) nwest = size ( self % west_stencils ) ! Compute rhs assuming periodicity rhs = self % bulk_stencil % apply_along ( f ) ! Fix rhs values near boundaries do ref = 1 , neast sten = self % east_stencils ( ref ) rhs ( ref ) = sten % apply ( f , ref ) end do do i = 1 , nwest sten = self % west_stencils ( i ) ref = size ( f ) - i + 1 rhs ( ref ) = sten % apply ( f , ref ) end do rhs = rhs / dx ! Solve tridiagonal system of equations diag = [( 1. , i = 1 , size ( f ))] ! Both upper and lower diagonals are declared of size n = size(f) ! instead of n-1, out of convenience. Components upper_diag(n) and ! lower_diag(1) will not be accessed by the thomas solver as they ! do not appear in the tridiagonal system. upper_diag = [ & & self % east_stencils % get_upper (), & & ( self % bulk_stencil % get_upper (), i = neast + 1 , size ( f ) - nwest ), & & reverse ( self % west_stencils % get_upper ()) & ] lower_diag = [ & & self % east_stencils % get_upper (), & & ( self % bulk_stencil % get_lower (), i = neast + 1 , size ( f ) - nwest ), & & reverse ( self % west_stencils % get_upper ()) & ] df = thomas ( lower_diag , diag , upper_diag , rhs ) end function diff_nonperiodic pure function diff_periodic ( self , f , dx ) result ( df ) !! Apply a differentiation stencil along a one dimensional pencil, !! assuming periodic boundaries. For instance, with a four point !! stencil s = (-2, -1, 1, 2) and weights {g_{i}}_{1 \\leq i !! \\leq 4} !! !!  g(1) = g_1f_{n-2} + g_2f_{n-1} + g_3f_{2} + g_4f_{3}  !!  g(2) = g_1f_{n-1} + g_2f_{1} + g_3f_{3} + g_4f_{4}  !! !!  g(i) = g_1f_{i-2} + g_2f_{i-1} + g_3f_{i+1} + g_4f_{i+2}, i = 3, n-2 !! !!  g(n-1) = g_1f_{n-3} + g_2f_{n-2} + g_3f_{n} + g_4f_{2}  !!  g(n) = g_1f_{n-2} + g_2f_{n-1} + g_3f_{2} + g_4f_{3}  class ( differentiator_type ), intent ( in ) :: self real , intent ( in ) :: f (:) !! Function to be derive, evaluated on pencil real , allocatable :: df (:) !! Derivative, evaluated on pencil real , intent ( in ) :: dx !! Step size real , allocatable :: rhs (:), diag (:), lower_diag (:), upper_diag (:) real , allocatable :: u (:), v (:), q (:), y (:) real :: gamma , up , low integer :: nx , i rhs = self % bulk_stencil % apply_along ( f ) rhs = rhs / dx ! Solve quasi-tridiagonal system of equations using the ! Shermann-Morrison formula up = self % bulk_stencil % get_upper () low = self % bulk_stencil % get_lower () gamma = - 1. nx = size ( f ) diag = [ & & 1. - gamma , & & ( 1. , i = 2 , nx - 1 ), & & 1. - ( up * low ) / gamma & & ] ! Both upper and lower diagonals are declared of size n = size(f) ! instead of n-1, out of convenience. Components upper_diag(n) and ! lower_diag(1) will not be accessed by the thomas solver as they ! do not appear in the tridiagonal system. nx = size ( f ) lower_diag = [( low , i = 1 , nx )] upper_diag = [( up , i = 1 , nx )] u = [ gamma , ( 0. , i = 2 , nx - 1 ), up ] v = [ 1. , ( 0. , i = 2 , nx - 1 ), low / gamma ] q = thomas ( lower_diag , diag , upper_diag , u ) y = thomas ( lower_diag , diag , upper_diag , rhs ) df = y - (( y ( 1 ) - low * y ( nx )) & & / ( 1. + q ( 1 ) - low * q ( nx ))) * q end function diff_periodic pure function reverse ( x ) real , intent ( in ) :: x (:) real , allocatable :: reverse (:) reverse = x ( size ( x ): 1 : - 1 ) end function reverse end module differentiate","tags":"","loc":"sourcefile/module_differentiate.f90.html"},{"title":"module_field.f90 – heatcompact3d","text":"Contents Modules field Source Code module_field.f90 Source Code module field implicit none type , abstract :: field_type !! Implement a 3D scalar field, for instance a temperature field. !! ```f90 !! type(field_type) = afield !! real :: u0(nx, ny, nz), dx !! afield = field_type(u0, dx) !! ``` real , allocatable :: data (:, :, :) real :: dx !! Discrete mesh spacing contains procedure , public :: nx , ny , nz procedure , public :: is_equal , dump procedure ( rhs_field ), deferred :: rhs procedure , private :: field_add_field , field_sub_field , & & field_mul_real , field_add_real generic :: operator ( + ) => field_add_field , field_add_real generic :: operator ( - ) => field_sub_field generic :: operator ( * ) => field_mul_real end type field_type interface pure function rhs_field ( self ) import :: field_type class ( field_type ), intent ( in ) :: self real , allocatable :: rhs_field (:, :, :) end function rhs_field end interface contains pure integer function nx ( self ) !! Returns domain size in \\mathbf{x} direction class ( field_type ), intent ( in ) :: self nx = size ( self % data , 1 ) end function nx pure integer function ny ( self ) !! Returns domain size in \\mathbf{y} direction class ( field_type ), intent ( in ) :: self ny = size ( self % data , 2 ) end function ny pure integer function nz ( self ) !! Returns domain size in \\mathbf{z} direction class ( field_type ), intent ( in ) :: self nz = size ( self % data , 3 ) end function nz pure logical function is_equal ( self , lhs , tol ) !! Compare two field_type instance based on their data value !! ```f90 !! f1 = field_type(u0, dx) !! f2 = field_type(u0, dx2) !! f1%is_equal(f2) ! true !! ``` class ( field_type ), intent ( in ) :: self !! Right hand side of comparison class ( field_type ), intent ( in ) :: lhs !! Left hand side of comparison real , intent ( in ) :: tol !! Absolute tolerance when comparing !! fields values logical , allocatable :: elmt_is_equal (:, :, :) elmt_is_equal = abs ( self % data - lhs % data ) < tol is_equal = all ( elmt_is_equal ) end function is_equal subroutine dump ( self , file_path , fmt ) !! Write field data to ASCII file class ( field_type ), intent ( in ) :: self character ( * ), intent ( in ) :: file_path !! Relative path to file to output file character ( * ), optional :: fmt !! Format string integer :: fileunit , i , j , k if (. not . present ( fmt )) fmt = 'f8.1' open ( newunit = fileunit , file = file_path , action = 'write' ) do k = 1 , size ( self % data , 3 ) do j = 1 , size ( self % data , 2 ) do i = 1 , size ( self % data , 1 ) write ( fileunit , fmt ) self % data ( i , j , k ) end do end do end do end subroutine dump pure function field_add_field ( self , afield ) class ( field_type ), intent ( in ) :: self , afield class ( field_type ), allocatable :: field_add_field allocate ( field_add_field , mold = self ) field_add_field % data = self % data + afield % data field_add_field % dx = self % dx end function field_add_field pure function field_add_real ( self , a ) class ( field_type ), intent ( in ) :: self real , intent ( in ) :: a (:, :, :) class ( field_type ), allocatable :: field_add_real allocate ( field_add_real , mold = self ) field_add_real % data = self % data + a field_add_real % dx = self % dx end function field_add_real pure function field_sub_field ( self , afield ) class ( field_type ), intent ( in ) :: self , afield class ( field_type ), allocatable :: field_sub_field allocate ( field_sub_field , mold = self ) field_sub_field % data = self % data - afield % data field_sub_field % dx = self % dx end function field_sub_field pure function field_mul_real ( self , a ) !! Multiply a `field_cpu_type` instance by a `real` number. !! ``` !! f1 = field_cpu_type(u0, dx) !! f2 = f1 * 1.3 !! f2%is_equal(field_cpu_type(u0 * 1.3, dx)) ! true !! ``` class ( field_type ), intent ( in ) :: self !! Left hand side real , intent ( in ) :: a !! Scalar to multiply field instance with class ( field_type ), allocatable :: field_mul_real allocate ( field_mul_real , mold = self ) field_mul_real % data = self % data * a field_mul_real % dx = self % dx end function field_mul_real end module field","tags":"","loc":"sourcefile/module_field.f90.html"},{"title":"module_boundary_schemes.f90 – heatcompact3d","text":"Contents Modules boundary_schemes Source Code module_boundary_schemes.f90 Source Code module boundary_schemes use stencil , only : stencil_type implicit none type boundary_type type ( stencil_type ) :: first_order_east ( 2 ), second_order_east ( 2 ) type ( stencil_type ) :: first_order_west ( 2 ), second_order_west ( 2 ) end type boundary_type real , parameter :: sixth_order_compact_coeffs ( 4 ) = [ & & - 1. / 3 6. , & & - 7. / 9. , & & + 7. / 9. , & & + 1. / 3 6. & & ] real , parameter :: sixth_order_compact_coeffs_2 ( 5 ) = [ & & 3. / 4 4. , & & 1 2. / 1 1. , & & - 2. * ( 1 2. / 1 1. + 3. / 4 4. ), & & 1 2. / 1 1. , & & 3. / 4 4. & & ] contains pure type ( stencil_type ) function sixth_order_compact_stencil () sixth_order_compact_stencil = stencil_type ( & & nodes = [ - 2 , - 1 , 1 , 2 ], & & coeffs = sixth_order_compact_coeffs , & & upper = 1. / 3. , & & lower = 1. / 3. & & ) end function sixth_order_compact_stencil pure type ( stencil_type ) function sixth_order_compact_second_stencil () sixth_order_compact_second_stencil = stencil_type ( & & nodes = [ - 2 , - 1 , 0 , 1 , 2 ], & & coeffs = sixth_order_compact_coeffs_2 , & & upper = 2. / 1 1. , & & lower = 2. / 1 1. & & ) end function sixth_order_compact_second_stencil type ( boundary_type ) function get_dirichlet_boundary () type ( stencil_type ) :: first_order_east ( 2 ), second_order_east ( 2 ) type ( stencil_type ) :: first_order_west ( 2 ), second_order_west ( 2 ) first_order_east ( 1 ) = stencil_type ( & & nodes = [ 0 , 1 , 2 , 3 ], & & coeffs = [ - 5. / 2. , 2. , 0.5 , 0. ], & & lower = 0. , upper = 2. & & ) first_order_east ( 2 ) = stencil_type ( & & nodes = [ - 1 , 0 , 1 , 2 ], & & coeffs = [ - 3. / 4. , 0. , 3. / 4. , 0. ], & & lower = 1. / 4. , upper = 1. / 4. & & ) second_order_east ( 1 ) = stencil_type ( & & nodes = [ 0 , 1 , 2 , 3 ], & & coeffs = [ 1 3. , - 2 7. , 1 5. , - 1. ], & & lower = 0. , upper = 1 1. & & ) second_order_east ( 2 ) = stencil_type ( & & nodes = [ - 1 , 0 , 1 , 2 ], & & coeffs = [ 6. / 5. , - 1 2. / 5. , 6. / 5. , 0. ], & & lower = 1. / 1 0. , upper = 1. / 1 0. & & ) first_order_west = first_order_east % flip () * ( - 1. ) second_order_west = second_order_east % flip () get_dirichlet_boundary = boundary_type ( & & first_order_east , second_order_east , first_order_west , second_order_west ) end function get_dirichlet_boundary end module boundary_schemes","tags":"","loc":"sourcefile/module_boundary_schemes.f90.html"},{"title":"module_field_cpu.f90 – heatcompact3d","text":"Contents Modules field_cpu Source Code module_field_cpu.f90 Source Code module field_cpu use field , only : field_type implicit none type , extends ( field_type ) :: field_cpu_type contains procedure , public :: rhs end type field_cpu_type interface field_cpu_type module procedure field_cpu_constructor end interface field_cpu_type contains function field_cpu_constructor ( initial , dx ) result ( afield ) real , intent ( in ) :: initial (:, :, :) !! Initial state real , intent ( in ) :: dx !! Spatial mesh spacing type ( field_cpu_type ) :: afield allocate ( afield % data , source = initial ) afield % dx = dx end function field_cpu_constructor pure function rhs ( self ) !! Evaluates right hand side of heat equation on a field instance. !!  F(T) = \\Delta T = \\frac{\\partial&#94;2 T}{\\partial x&#94;2} + !! \\frac{\\partial&#94;2 T}{\\partial y&#94;2} + \\frac{\\partial&#94;2 !! T}{\\partial z&#94;2}  !! use differentiate , only : differentiator_type , & & sixth_order_compact_1 , sixth_order_compact_2 class ( field_cpu_type ), intent ( in ) :: self real , allocatable :: ddx (:, :, :), ddy (:, :, :), ddz (:, :, :) real , allocatable :: rhs (:, :, :) integer :: ix , iy , iz real :: dx2 class ( differentiator_type ), allocatable :: differ dx2 = self % dx * self % dx differ = sixth_order_compact_2 () ! Periodic boundaries allocate ( ddx , source = self % data ) do iz = 1 , self % nz () do iy = 1 , self % ny () ddx (:, iy , iz ) = differ % diff ( self % data (:, iy , iz ), dx2 ) end do end do allocate ( ddy , source = self % data ) do iz = 1 , self % nz () do ix = 1 , self % nx () ddy ( ix , :, iz ) = differ % diff ( self % data ( ix , :, iz ), dx2 ) end do end do allocate ( ddz , source = self % data ) do iy = 1 , self % ny () do ix = 1 , self % nx () ddz ( ix , iy , :) = differ % diff ( self % data ( ix , iy , :), dx2 ) end do end do rhs = ddx + ddy + ddz end function rhs end module field_cpu","tags":"","loc":"sourcefile/module_field_cpu.f90.html"},{"title":"module_stencil.f90 – heatcompact3d","text":"Contents Modules stencil Source Code module_stencil.f90 Source Code module stencil implicit none type :: stencil_type integer , allocatable :: nodes (:) real , allocatable :: coeffs (:) real :: lower , upper contains procedure , private :: stencil_mul_real procedure , public :: apply => apply_stencil procedure , public :: apply_along => apply_stencil_along procedure , public :: get_upper , get_lower procedure , public :: flip , is_equal generic :: operator ( * ) => stencil_mul_real end type stencil_type contains pure logical function is_equal ( self , st , tol ) class ( stencil_type ), intent ( in ) :: self type ( stencil_type ), intent ( in ) :: st real , intent ( in ) :: tol logical nodes_equal , coeffs_equal nodes_equal = all ( self % nodes == st % nodes ) coeffs_equal = all ( abs ( self % coeffs - st % coeffs ) < tol ) is_equal = nodes_equal . and . coeffs_equal end function is_equal pure elemental type ( stencil_type ) function stencil_mul_real ( self , a ) class ( stencil_type ), intent ( in ) :: self real , intent ( in ) :: a integer , allocatable :: nodes (:) real , allocatable :: coeffs (:) nodes = self % nodes coeffs = self % coeffs stencil_mul_real = stencil_type ( & & nodes = nodes , & & coeffs = a * coeffs , & & lower = self % lower , upper = self % upper & & ) end function stencil_mul_real pure elemental type ( stencil_type ) function flip ( self ) class ( stencil_type ), intent ( in ) :: self integer , allocatable :: nodes (:) real , allocatable :: coeffs (:) nodes = self % nodes coeffs = self % coeffs flip = stencil_type ( & & nodes = - nodes , & & coeffs = coeffs , & & lower = self % lower , upper = self % upper & & ) end function flip pure elemental real function get_upper ( self ) class ( stencil_type ), intent ( in ) :: self get_upper = self % upper end function get_upper pure elemental real function get_lower ( self ) class ( stencil_type ), intent ( in ) :: self get_lower = self % lower end function get_lower pure real function apply_stencil ( self , f , ref ) class ( stencil_type ), intent ( in ) :: self real , intent ( in ) :: f (:) integer , intent ( in ) :: ref real , allocatable :: eval (:) eval = f ( self % nodes + ref ) apply_stencil = dot_product ( eval , self % coeffs ) end function apply_stencil pure function apply_stencil_along ( self , f ) class ( stencil_type ), intent ( in ) :: self real , intent ( in ) :: f (:) real , allocatable :: apply_stencil_along (:), f_padded (:), eval (:) integer :: ref , i , lpad , rpad lpad = minval ( self % nodes ) + 1 rpad = size ( f ) + maxval ( self % nodes ) allocate ( f_padded ( lpad : rpad )) do i = lpad , 0 f_padded ( i ) = f ( size ( f ) + i - 1 ) end do do i = size ( f ) + 1 , rpad f_padded ( i ) = f ( i - size ( f ) + 1 ) end do f_padded ( 1 : size ( f )) = f allocate ( apply_stencil_along , source = f ) do ref = 1 , size ( f ) ! Would be nice to reuse self%apply_stencil here but any ! negative indices are lost when passing f_padded eval = f_padded ( self % nodes + ref ) apply_stencil_along ( ref ) = dot_product ( eval , self % coeffs ) end do end function apply_stencil_along end module stencil","tags":"","loc":"sourcefile/module_stencil.f90.html"},{"title":"module_field_gpu.f90 – heatcompact3d","text":"Contents Modules field_gpu Source Code module_field_gpu.f90 Source Code module field_gpu use cudafor use field , only : field_type implicit none type , extends ( field_type ) :: field_gpu_type contains procedure , public :: rhs end type field_gpu_type interface field_gpu_type module procedure field_gpu_constructor end interface field_gpu_type contains function field_gpu_constructor ( initial , dx ) result ( afield ) real , intent ( in ) :: initial (:, :, :) !! Initial state real , intent ( in ) :: dx !! Spatial mesh spacing type ( field_gpu_type ) :: afield allocate ( afield % data , source = initial ) afield % dx = dx end function field_gpu_constructor pure function rhs ( self ) class ( field_gpu_type ), intent ( in ) :: self real , allocatable :: rhs (:, :, :) real , allocatable , device :: rhs_dev (:, :, :), data_dev (:, :, :), temp_dev (:, :, :) type ( dim3 ) :: threads , grid integer , parameter :: th = 16 select type ( self ) type is ( field_gpu_type ) allocate ( data_dev , mold = self % data ) allocate ( rhs_dev , mold = self % data ) allocate ( temp_dev , mold = self % data ) rhs_dev = self % data ! x-directional derivatives grid = dim3 ( ceiling ( real ( self % ny ()) / th ), ceiling ( real ( self % nz ()) / th ), 1 ) threads = dim3 ( th , th , 1 ) call rhs_x <<< grid , threads >>> ( data_dev , rhs_dev , temp_dev ) ! y-directional derivatives grid = dim3 ( ceiling ( real ( self % nx ()) / th ), ceiling ( real ( self % nz ()) / th ), 1 ) threads = dim3 ( th , th , 1 ) call rhs_y <<< grid , threads >>> ( data_dev , rhs_dev , temp_dev ) ! z-directional derivatives grid = dim3 ( ceiling ( real ( self % nx ()) / th ), ceiling ( real ( self % ny ()) / th ), 1 ) threads = dim3 ( th , th , 1 ) call rhs_z <<< grid , threads >>> ( data_dev , rhs_dev , temp_dev ) rhs = rhs_dev end select end function rhs attributes ( global ) pure subroutine rhs_x ( data , rhs , temp ) real , intent ( in ) :: data (:, :, :) real , intent ( out ) :: rhs (:, :, :) real , intent ( inout ) :: temp (:, :, :) integer :: x , y , z , nx , ny , nz real :: dx nx = size ( data , dim = 1 ) ny = size ( data , dim = 2 ) nz = size ( data , dim = 3 ) y = blockDim % x * ( blockIdx % x - 1 ) + threadIdx % x z = blockDim % y * ( blockIdx % y - 1 ) + threadIdx % y dx = 2. * acos ( - 1. ) / ( nx - 1 ) if ( y <= ny . and . z <= nz ) then ! Construct the RHS and apply Forward Thomas do x = 1 , nx temp ( x , y , z ) = data ( x , y , z ) end do ! Backward Thomas do x = nx , 1 , - 1 temp ( x , y , z ) = - 1. * cos (( x - 1 ) * dx ) * cos (( y - 1 ) * dx ) * cos (( z - 1 ) * dx ) !2.*temp(x, y, z) end do ! Periodic last pass do x = 1 , nx rhs ( x , y , z ) = temp ( x , y , z ) end do end if end subroutine rhs_x attributes ( global ) pure subroutine rhs_y ( data , rhs , temp ) real , intent ( in ) :: data (:, :, :) real , intent ( inout ) :: rhs (:, :, :) real , intent ( inout ) :: temp (:, :, :) integer :: x , y , z , nx , ny , nz real :: dx nx = size ( data , dim = 1 ) ny = size ( data , dim = 2 ) nz = size ( data , dim = 3 ) x = blockDim % x * ( blockIdx % x - 1 ) + threadIdx % x z = blockDim % y * ( blockIdx % y - 1 ) + threadIdx % y dx = 2. * acos ( - 1. ) / ( nx - 1 ) if ( x <= nx . and . z <= nz ) then ! Construct the RHS and apply Forward Thomas do y = 1 , ny temp ( x , y , z ) = data ( x , y , z ) end do ! Backward Thomas do y = ny , 1 , - 1 temp ( x , y , z ) = - 1. * cos (( x - 1 ) * dx ) * cos (( y - 1 ) * dx ) * cos (( z - 1 ) * dx ) !2.*temp(x, y, z) end do ! Periodic last pass do y = 1 , ny rhs ( x , y , z ) = rhs ( x , y , z ) + temp ( x , y , z ) end do end if end subroutine rhs_y attributes ( global ) pure subroutine rhs_z ( data , rhs , temp ) real , intent ( in ) :: data (:, :, :) real , intent ( inout ) :: rhs (:, :, :) real , intent ( inout ) :: temp (:, :, :) integer :: x , y , z , nx , ny , nz real :: dx nx = size ( data , dim = 1 ) ny = size ( data , dim = 2 ) nz = size ( data , dim = 3 ) x = blockDim % x * ( blockIdx % x - 1 ) + threadIdx % x y = blockDim % y * ( blockIdx % y - 1 ) + threadIdx % y dx = 2. * acos ( - 1. ) / ( nx - 1 ) if ( x <= nx . and . y <= ny ) then ! Construct the RHS and apply Forward Thomas do z = 1 , nz temp ( x , y , z ) = data ( x , y , z ) end do ! Backward Thomas do z = nz , 1 , - 1 temp ( x , y , z ) = - 1. * cos (( x - 1 ) * dx ) * cos (( y - 1 ) * dx ) * cos (( z - 1 ) * dx ) !2.*temp(x, y, z) end do ! Periodic last pass do z = 1 , nz rhs ( x , y , z ) = rhs ( x , y , z ) + temp ( x , y , z ) end do end if end subroutine rhs_z end module field_gpu","tags":"","loc":"sourcefile/module_field_gpu.f90.html"}]}